package com.surgeplay.glow;

import java.nio.IntBuffer;
import java.util.HashMap;
import java.util.Map;

import org.lwjgl.BufferUtils;

import com.surgeplay.glow.gl.CompatibleGL;

import static com.surgeplay.glow.GLConstant.*;

/**
 * Values in this enum correspond to GL_EnumName constants in GL.
 */
public enum GLLimit {
	MAX_COMPUTE_SHADER_STORAGE_BLOCKS		(GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS),
	MAX_COMBINED_SHADER_STORAGE_BLOCKS		(GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS),
	MAX_COMPUTE_UNIFORM_BLOCKS				(GL_MAX_COMPUTE_UNIFORM_BLOCKS),
	MAX_COMPUTE_TEXTURE_IMAGE_UNITS			(GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS),
	MAX_COMPUTE_UNIFORM_COMPONENTS			(GL_MAX_COMPUTE_UNIFORM_COMPONENTS),
	MAX_COMPUTE_ATOMIC_COUNTERS				(GL_MAX_COMPUTE_ATOMIC_COUNTERS),
	MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS		(GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS),
	MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS	(GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS),
	MAX_COMPUTE_WORK_GROUP_INVOCATIONS		(GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS),
	MAX_DEBUG_GROUP_STACK_DEPTH				(GL_MAX_DEBUG_GROUP_STACK_DEPTH),
	/** Only a rough estimate- use a GL_PROXY_TEXTURE_3D dry-run to determine if a specific texture size would be too big. */
	MAX_3D_TEXTURE_SIZE						(GL_MAX_3D_TEXTURE_SIZE),
	MAX_ARRAY_TEXTURE_LAYERS				(GL_MAX_ARRAY_TEXTURE_LAYERS),
	MAX_CLIP_DISTANCES						(GL_MAX_CLIP_DISTANCES),
	MAX_COLOR_TEXTURE_SAMPLES				(GL_MAX_COLOR_TEXTURE_SAMPLES),
	MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS(GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS),
	MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS(GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS),
	MAX_COMBINED_TEXTURE_IMAGE_UNITS		(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
	MAX_COMBINED_UNIFORM_BLOCKS				(GL_MAX_COMBINED_UNIFORM_BLOCKS),
	MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS	(GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS),
	MAX_CUBE_MAP_TEXTURE_SIZE				(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
	MAX_DEPTH_TEXTURE_SAMPLES				(GL_MAX_DEPTH_TEXTURE_SAMPLES),
	MAX_DRAW_BUFFERS						(GL_MAX_DRAW_BUFFERS),
	MAX_DUAL_SOURCE_DRAW_BUFFERS			(GL_MAX_DUAL_SOURCE_DRAW_BUFFERS),
	MAX_ELEMENTS_INDICES					(GL_MAX_ELEMENTS_INDICES),
	MAX_ELEMENTS_VERTICES					(GL_MAX_ELEMENTS_VERTICES),
	MAX_FRAGMENT_ATOMIC_COUNTERS			(GL_MAX_FRAGMENT_ATOMIC_COUNTERS),
	MAX_FRAGMENT_SHADER_STORAGE_BLOCKS		(GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS),
	MAX_FRAGMENT_INPUT_COMPONENTS			(GL_MAX_FRAGMENT_INPUT_COMPONENTS),
	MAX_FRAGMENT_UNIFORM_COMPONENTS			(GL_MAX_FRAGMENT_UNIFORM_COMPONENTS),
	MAX_FRAGMENT_UNIFORM_BLOCKS				(GL_MAX_FRAGMENT_UNIFORM_BLOCKS),
	MAX_FRAMEBUFFER_WIDTH					(GL_MAX_FRAMEBUFFER_WIDTH),
	MAX_FRAMEBUFFER_HEIGHT					(GL_MAX_FRAMEBUFFER_HEIGHT),
	MAX_FRAMEBUFFER_LAYERS					(GL_MAX_FRAMEBUFFER_LAYERS),
	MAX_FRAMEBUFFER_SAMPLES					(GL_MAX_FRAMEBUFFER_SAMPLES),
	MAX_GEOMETRY_ATOMIC_COUNTERS			(GL_MAX_GEOMETRY_ATOMIC_COUNTERS),
	MAX_GEOMETRY_SHADER_STORAGE_BLOCKS		(GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS),
	MAX_GEOMETRY_INPUT_COMPONENTS			(GL_MAX_GEOMETRY_INPUT_COMPONENTS),
	MAX_GEOMETRY_OUTPUT_COMPONENTS			(GL_MAX_GEOMETRY_OUTPUT_COMPONENTS),
	MAX_GEOMETRY_TEXTURE_IMAGE_UNITS		(GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS),
	MAX_GEOMETRY_UNIFORM_BLOCKS				(GL_MAX_GEOMETRY_UNIFORM_BLOCKS),
	MAX_GEOMETRY_UNIFORM_COMPONENTS			(GL_MAX_GEOMETRY_UNIFORM_COMPONENTS),
	MAX_INTEGER_SAMPLES						(GL_MAX_INTEGER_SAMPLES),
	MIN_MAP_BUFFER_ALIGNMENT				(GL_MIN_MAP_BUFFER_ALIGNMENT),
	MAX_LABEL_LENGTH						(GL_MAX_LABEL_LENGTH),
	MAX_PROGRAM_TEXEL_OFFSET				(GL_MAX_PROGRAM_TEXEL_OFFSET),
	MIN_PROGRAM_TEXEL_OFFSET				(GL_MIN_PROGRAM_TEXEL_OFFSET),
	MAX_RECTANGLE_TEXTURE_SIZE				(GL_MAX_RECTANGLE_TEXTURE_SIZE),
	MAX_RENDERBUFFER_SIZE					(GL_MAX_RENDERBUFFER_SIZE),
	MAX_SAMPLE_MASK_WORDS					(GL_MAX_SAMPLE_MASK_WORDS),
	MAX_SERVER_WAIT_TIMEOUT					(GL_MAX_SERVER_WAIT_TIMEOUT),
	MAX_SHADER_STORAGE_BUFFER_BINDINGS		(GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS),
	MAX_TESS_CONTROL_ATOMIC_COUNTERS		(GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS),
	MAX_TESS_EVALUATION_ATOMIC_COUNTERS		(GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS),
	MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS	(GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS),
	MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS(GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS),
	MAX_TEXTURE_BUFFER_SIZE					(GL_MAX_TEXTURE_BUFFER_SIZE),
	MAX_TEXTURE_IMAGE_UNITS					(GL_MAX_TEXTURE_IMAGE_UNITS),
	MAX_TEXTURE_LOD_BIAS					(GL_MAX_TEXTURE_LOD_BIAS),
	MAX_TEXTURE_SIZE						(GL_MAX_TEXTURE_SIZE),
	MAX_UNIFORM_BUFFER_BINDINGS				(GL_MAX_UNIFORM_BUFFER_BINDINGS),
	MAX_UNIFORM_BLOCK_SIZE					(GL_MAX_UNIFORM_BLOCK_SIZE),
	MAX_UNIFORM_LOCATIONS					(GL_MAX_UNIFORM_LOCATIONS),
	MAX_VARYING_COMPONENTS					(GL_MAX_VARYING_COMPONENTS),
	MAX_VARYING_VECTORS						(GL_MAX_VARYING_VECTORS),
	MAX_VARYING_FLOATS						(GL_MAX_VARYING_FLOATS),
	MAX_VERTEX_ATOMIC_COUNTERS				(GL_MAX_VERTEX_ATOMIC_COUNTERS),
	MAX_VERTEX_ATTRIBS						(GL_MAX_VERTEX_ATTRIBS),
	MAX_VERTEX_SHADER_STORAGE_BLOCKS		(GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS),
	MAX_VERTEX_TEXTURE_IMAGE_UNITS			(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),
	MAX_VERTEX_UNIFORM_COMPONENTS			(GL_MAX_VERTEX_UNIFORM_COMPONENTS),
	MAX_VERTEX_UNIFORM_VECTORS				(GL_MAX_VERTEX_UNIFORM_VECTORS),
	MAX_VERTEX_OUTPUT_COMPONENTS			(GL_MAX_VERTEX_OUTPUT_COMPONENTS),
	MAX_VERTEX_UNIFORM_BLOCKS				(GL_MAX_VERTEX_UNIFORM_BLOCKS),
	MAX_VIEWPORT_WIDTH	(GL_MAX_VIEWPORT_DIMS, 0), //half of MAX_VIEWPORT_DIMS
	MAX_VIEWPORT_HEIGHT	(GL_MAX_VIEWPORT_DIMS, 1),//half of MAX_VIEWPORT_DIMS
	MAX_VIEWPORTS,
	MAX_VERTEX_ATTRIB_RELATIVE_OFFSET,
	MAX_VERTEX_ATTRIB_BINDINGS,
	MAX_ELEMENT_INDEX,
	;
	
	private final int glConstant;
	private final int index;
	private boolean memoized = false;
	private int result = -1;
	
	GLLimit() { glConstant = GL_FALSE; index = -1; }
	GLLimit(int glConstant) {
		this.glConstant = glConstant;
		this.index = -1;
	}
	GLLimit(int glConstant, int index) {
		this.glConstant = glConstant;
		this.index = -1;
	}
	
	public int value() { return glConstant; }
	
	public int get() {
		if (!memoized && glConstant!=GL_FALSE) {
			if (index==-1) {
				result = CompatibleGL.getInstance().glGetInteger(glConstant);
			} else {
				IntBuffer buf = BufferUtils.createIntBuffer(index+1);
				CompatibleGL.getInstance().glGetIntegerv(glConstant, buf);
				result = buf.get(index);
			}
			memoized = true;
		}
		return result;
	}
	
	public static void forgetEverything() {
		for(GLLimit limit : values()) limit.memoized = false;
	}
	
	public static Map<GLLimit, Integer> all() {
		HashMap<GLLimit, Integer> result = new HashMap<>();
		for(GLLimit limit : values()) {
			if(limit.glConstant==GL_FALSE) continue;
			result.put(limit, limit.get());
		}
		return result;
	}
}
